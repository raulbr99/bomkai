import Anthropic from '@anthropic-ai/sdk';
import { NextRequest } from 'next/server';
import type { ConfiguracionLibro, Outline } from '@/lib/types';

// Inicializar cliente de Anthropic
const anthropic = new Anthropic({
  apiKey: process.env.NEXT_PUBLIC_ANTHROPIC_API_KEY,
});

export async function POST(request: NextRequest) {
  console.log('üöÄ [generar-capitulo] Iniciando endpoint');
  
  try {
    // Log de headers para debugging
    console.log('üìã [generar-capitulo] Headers recibidos:', {
      'content-type': request.headers.get('content-type'),
      'user-agent': request.headers.get('user-agent'),
    });

    console.log('üì• [generar-capitulo] Parseando body de la request...');
    const body = await request.json();
    console.log('‚úÖ [generar-capitulo] Body parseado exitosamente');
    
    const {
      numeroCapitulo,
      outline,
      configuracion,
      resumenesAnteriores,
    }: {
      numeroCapitulo: number;
      outline: Outline;
      configuracion: ConfiguracionLibro;
      resumenesAnteriores: string[];
    } = body;

    // Log de par√°metros recibidos
    console.log('üìä [generar-capitulo] Par√°metros recibidos:', {
      numeroCapitulo,
      tituloLibro: outline?.titulo,
      genero: configuracion?.genero,
      cantidadCapitulos: outline?.capitulos?.length,
      resumenesAnteriores: resumenesAnteriores?.length || 0,
    });

    // Validar par√°metros requeridos
    if (!numeroCapitulo || !outline || !configuracion) {
      console.error('‚ùå [generar-capitulo] Par√°metros faltantes:', {
        numeroCapitulo: !!numeroCapitulo,
        outline: !!outline,
        configuracion: !!configuracion,
      });
      return new Response(
        JSON.stringify({ 
          tipo: 'error', 
          contenido: 'Par√°metros requeridos faltantes: numeroCapitulo, outline, configuracion' 
        }),
        {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    // Validar que tenemos la API key (corregir nombre de variable)
    const apiKey = process.env.NEXT_PUBLIC_ANTHROPIC_API_KEY;
    console.log('üîë [generar-capitulo] Verificando API key:', {
      hasApiKey: !!apiKey,
      keyLength: apiKey?.length || 0,
      keyPrefix: apiKey?.substring(0, 10) || 'N/A',
    });
    
    if (!apiKey) {
      console.error('‚ùå [generar-capitulo] API key no configurada');
      return new Response(
        JSON.stringify({ tipo: 'error', contenido: 'ANTHROPIC_API_KEY no est√° configurada' }),
        {
          status: 500,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    // Construir el prompt para generar el cap√≠tulo
    console.log('üìù [generar-capitulo] Construyendo prompt...');
    let prompt: string;
    try {
      prompt = construirPromptCapitulo(
        numeroCapitulo,
        outline,
        configuracion,
        resumenesAnteriores
      );
      console.log('‚úÖ [generar-capitulo] Prompt construido exitosamente:', {
        promptLength: prompt.length,
        numeroCapitulo,
        tituloCapitulo: outline.capitulos.find(cap => cap.numero === numeroCapitulo)?.titulo,
      });
    } catch (promptError) {
      console.error('‚ùå [generar-capitulo] Error construyendo prompt:', promptError);
      throw promptError;
    }

    // Crear un ReadableStream para streaming
    console.log('üåä [generar-capitulo] Iniciando streaming...');
    const encoder = new TextEncoder();
    let contenidoCompleto = '';

    const stream = new ReadableStream({
      async start(controller) {
        try {
          console.log('ü§ñ [generar-capitulo] Llamando a Anthropic API...');
          
          // Usar streaming de Anthropic
          const streamResponse = await anthropic.messages.stream({
            model: 'claude-sonnet-4-5-20250929',
            max_tokens: 8000,
            messages: [
              {
                role: 'user',
                content: prompt,
              },
            ],
          });
          
          console.log('‚úÖ [generar-capitulo] Conexi√≥n con Anthropic establecida');

          // Procesar cada chunk del stream
          console.log('üì¶ [generar-capitulo] Procesando chunks del stream...');
          let chunkCount = 0;
          
          for await (const event of streamResponse) {
            if (event.type === 'content_block_delta') {
              if (event.delta.type === 'text_delta') {
                chunkCount++;
                const texto = event.delta.text;
                contenidoCompleto += texto;

                // Log cada 50 chunks para no saturar los logs
                if (chunkCount % 50 === 0) {
                  console.log(`üìä [generar-capitulo] Procesados ${chunkCount} chunks, contenido: ${contenidoCompleto.length} caracteres`);
                }

                // Enviar chunk al cliente
                const chunk = {
                  tipo: 'chunk',
                  contenido: texto,
                };
                const data = `data: ${JSON.stringify(chunk)}\n\n`;
                controller.enqueue(encoder.encode(data));
              }
            }
          }

          console.log(`‚úÖ [generar-capitulo] Stream completado. Total chunks: ${chunkCount}, contenido final: ${contenidoCompleto.length} caracteres`);

          // Enviar mensaje de completado
          const mensajeFinal = {
            tipo: 'completo',
            contenido: contenidoCompleto,
          };
          const data = `data: ${JSON.stringify(mensajeFinal)}\n\n`;
          controller.enqueue(encoder.encode(data));

          controller.close();
        } catch (error) {
          console.error('‚ùå [generar-capitulo] Error en streaming:', {
            error: error instanceof Error ? error.message : 'Error desconocido',
            stack: error instanceof Error ? error.stack : undefined,
            name: error instanceof Error ? error.name : undefined,
          });
          
          const mensajeError = {
            tipo: 'error',
            contenido: error instanceof Error ? error.message : 'Error desconocido',
          };
          const data = `data: ${JSON.stringify(mensajeError)}\n\n`;
          controller.enqueue(encoder.encode(data));
          controller.close();
        }
      },
    });

    console.log('üéØ [generar-capitulo] Retornando stream response');
    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        Connection: 'keep-alive',
      },
    });
  } catch (error) {
    console.error('‚ùå [generar-capitulo] Error general en endpoint:', {
      error: error instanceof Error ? error.message : 'Error desconocido',
      stack: error instanceof Error ? error.stack : undefined,
      name: error instanceof Error ? error.name : undefined,
      timestamp: new Date().toISOString(),
    });
    
    return new Response(
      JSON.stringify({
        tipo: 'error',
        contenido: error instanceof Error ? error.message : 'Error desconocido',
      }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json' },
      }
    );
  }
}

/**
 * Construye el prompt para generar un cap√≠tulo espec√≠fico
 */
function construirPromptCapitulo(
  numeroCapitulo: number,
  outline: Outline,
  configuracion: ConfiguracionLibro,
  resumenesAnteriores: string[]
): string {
  console.log('üîç [construirPromptCapitulo] Iniciando construcci√≥n de prompt:', {
    numeroCapitulo,
    totalCapitulos: outline.capitulos?.length || 0,
    resumenesCount: resumenesAnteriores?.length || 0,
  });

  const capituloInfo = outline.capitulos.find(cap => cap.numero === numeroCapitulo);

  if (!capituloInfo) {
    console.error('‚ùå [construirPromptCapitulo] Cap√≠tulo no encontrado:', {
      numeroCapitulo,
      capitulosDisponibles: outline.capitulos.map(cap => ({ numero: cap.numero, titulo: cap.titulo })),
    });
    throw new Error(`No se encontr√≥ informaci√≥n para el cap√≠tulo ${numeroCapitulo}`);
  }

  console.log('‚úÖ [construirPromptCapitulo] Cap√≠tulo encontrado:', {
    numero: capituloInfo.numero,
    titulo: capituloInfo.titulo,
    descripcionLength: capituloInfo.descripcion?.length || 0,
  });

  let prompt = `Eres un escritor profesional talentoso escribiendo el Cap√≠tulo ${numeroCapitulo} de un libro.

CONTEXTO DEL LIBRO:
- T√≠tulo: ${outline.titulo}
- G√©nero: ${configuracion.genero}
- Estilo de escritura: ${configuracion.estiloEscritura}
- Tono: ${configuracion.tono}
- Audiencia objetivo: ${configuracion.audienciaObjetivo}
- Sinopsis: ${outline.sinopsis}

ARCO NARRATIVO GENERAL:
${outline.arcoNarrativo}
`;

  // A√±adir personajes si existen
  if (outline.personajes && outline.personajes.length > 0) {
    prompt += `\nPERSONAJES PRINCIPALES:\n`;
    for (const personaje of outline.personajes) {
      prompt += `- ${personaje.nombre}: ${personaje.descripcion}\n`;
    }
  }

  // A√±adir res√∫menes de cap√≠tulos anteriores
  if (resumenesAnteriores.length > 0) {
    prompt += `\nRESUMEN DE CAP√çTULOS ANTERIORES:\n`;
    resumenesAnteriores.forEach((resumen, index) => {
      prompt += `\nCap√≠tulo ${index + 1}:\n${resumen}\n`;
    });
  }

  prompt += `\nOBJETIVO DEL CAP√çTULO ${numeroCapitulo}:
T√≠tulo: "${capituloInfo.titulo}"
Descripci√≥n: ${capituloInfo.descripcion}

INSTRUCCIONES:
Escribe el cap√≠tulo completo con las siguientes caracter√≠sticas:
- Apertura atractiva que enganche al lector
- Contenido bien desarrollado (2000-3500 palabras aproximadamente)
- Flujo natural desde los cap√≠tulos anteriores (si aplica)
- Di√°logos naturales y descripciones inmersivas
- Avance de la trama o desarrollo de temas clave
- Final del cap√≠tulo que invite a seguir leyendo
- Mant√©n consistencia en estilo, tono y voz narrativa

Escribe de manera profesional y apropiada para el g√©nero y audiencia especificados. NO incluyas el t√≠tulo del cap√≠tulo en tu respuesta, solo el contenido narrativo.

Comienza a escribir el cap√≠tulo ahora:`;

  console.log('‚úÖ [construirPromptCapitulo] Prompt construido exitosamente:', {
    promptLength: prompt.length,
    hasPersonajes: outline.personajes && outline.personajes.length > 0,
    hasResumenes: resumenesAnteriores.length > 0,
  });

  return prompt;
}
